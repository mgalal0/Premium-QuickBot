/////////Ø¬Ù„Ø§Ù„ Ù…ØªØ¹Ù…Ù„Ø´ Ø§ÙŠ Ø­Ø§Ø¬Ø© Ø®Ø§Ù„Øµ Ø§ÙØªØ­ ÙˆÙŠ Ø§ÙÙ‡Ù…Ùƒ//////////////
/////////////////////////////////////////////////////
/////////////////////////
///////////////
///Ù…ØªØ¬ÙŠØ´ Ø¬Ù†Ø¨ Ø§ÙŠ Ø­Ø§Ø¬Ø© Ù‡Ù†Ø§ Ù‡Ù†Ø¹Ù…Ù…Ù„Ù‡Ø§  
/////Packaage ÙÙŠ Ø§Ù„Ø§Ø®ÙŠØ± Ø¨Ø¹Ø¯ ÙƒÙ„ Ø¨Ø±Ù…ÙŠÙˆÙ…
//// 
/////////////////////////////////////////














///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const devs = ['411137717884289024','id','Id'];

client.on('message', message => {
    let argresult = message.content.split(` `).slice(1).join(' ');
    if (message.content.startsWith(prefix + 'setT')) {
      if (!devs.includes(message.author.id)) return message.channel.send("**Only Premium**.");
      message.delete();
      client.user.setGame(argresult, 'https://twitch.tv/quastyle11');

    } else if(message.content.startsWith(prefix + 'setWt')) {
        client.user.setActivity(argresult,{type: 'WATCHING'});

      } else if(message.content.startsWith(prefix + 'setLt')) {
        client.user.setActivity(argresult,{type: 'LISTENING'});

      } else if(message.content.startsWith(prefix + 'setPlay')) {
        client.user.setActivity(argresult,{type: 'PLAYING'});

      } else if(message.content.startsWith(prefix + 'setName')) {
        client.user.setUsername(argresult);

      } else if(message.content.startsWith(prefix + 'setAvatar')) {
        client.user.setAvatar(argresult);


      } else if(message.content.startsWith(prefix + 'setStatus')) {
        if(!argresult) return message.channel.send('`online`, `DND(Do not Distrub),` `idle`, `invisible(Offline)` :notes: Ø£Ø®ØªØ± Ø£Ø­Ø¯ Ø§Ù„Ø­Ø§Ù„Ø§Øª');
        client.user.setStatus(argresult);


    }

  });

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////// ÙˆØµÙ ÙƒÙˆØ¯ Ø¯ÙŠÙÙˆÙ†  Ù…Ø¹ Ø§Ø¨ Ù† Ù„Ù„Ø¨Ø±Ù…ÙŠÙˆÙ… Ø¯Ø§ 

 client.on('message', message => {
        var prefix = "q";
        if(message.content.startsWith(prefix + 'deafen')) {
      if (message.mentions.users.size === 0 && message.mentions.roles.size === 0) {
        return message.reply('**ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ù…Ù†Ø´Ù† Ø§ÙˆÙ„Ø§Ù‘**:x:').catch(console.error);
      }
      if (!message.guild.member(client.user).hasPermission('DEAFEN_MEMBERS')) {
        return message.reply('Ù„Ù„Ø£Ø³Ù Ø§Ù„Ø¨ÙˆØª Ù„Ø§ ÙŠÙ…ØªÙ„Ùƒ ØµÙ„Ø§Ø­ÙŠØ§Øª Ù„ØªÙ†ÙÙŠØ° Ù‡Ø°Ù‡ Ø§Ù„Ø£Ù…Ø±**:x:').catch(console.error);
      }
     
      const deafenMember = (member) => {
        if (!member || !member.voiceChannel) return;
        if (member.serverDeaf) return message.channel.send(`${member} **Ù„Ø¯ÙŠÙ‡ Ø¯ÙŠÙÙ† Ø¨Ø§Ù„ÙØ¹Ù„**:x:`);
        member.setDeaf(true).catch(console.error);
        if(!message.member.hasPermission("DEAFEN_MEMBERS")) return message.channel.sendMessage("**Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ø§Ø¹Ø·Ø§Ø¡ Ø¯ÙŠÙÙ† **:x: ").then(m => m.delete(5000));
      };
     
      message.mentions.users.forEach(user => deafenMember(message.guild.member(user)));
      message.mentions.roles.forEach(role => role.members.forEach(member => deafenMember(member)));
        }
        
    });  
     
    client.on('message', async message =>{
      var prefix = "q";
      if(message.content.startsWith(prefix + 'undeafen')) {
     
    if (message.mentions.users.size === 0 && message.mentions.roles.size === 0) {
      return message.reply('**ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ù…Ù†Ø´Ù† Ø§ÙˆÙ„Ø§Ù‘**:x:').catch(console.error);
    }
    if (!message.guild.member(client.user).hasPermission('DEAFEN_MEMBERS')) {
      return message.reply('**Ù„Ù„Ø£Ø³Ù Ø§Ù„Ø¨ÙˆØª Ù„Ø§ ÙŠÙ…ØªÙ„Ùƒ ØµÙ„Ø§Ø­ÙŠØ§Øª Ù„ØªÙ†ÙÙŠØ° Ù‡Ø°Ù‡ Ø§Ù„Ø£Ù…Ø±**:x: ').catch(console.error);
      if(!message.member.hasPermission("DEAFEN_MEMBERS")) return message.channel.sendMessage("**Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ø§Ø¹Ø·Ø§Ø¡ Ø¯ÙŠÙÙ† **:x: ").then(m => m.delete(5000));
    }
     
    const undeafenMember = (member) => {
      if (!member || !member.voiceChannel) return;
      if (!member.serverDeaf) return message.channel.send(`${member} `);
      member.setDeaf(false).catch(console.error);
    };
     
    message.mentions.users.forEach(user => undeafenMember(message.guild.member(user)));
    message.mentions.roles.forEach(role => role.members.forEach(member => undeafenMember(member)));
    }
    });
  



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


















///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////Ù‡Ù†Ø§  Ø§Ù†ÙÙˆ Ø§Ù†ÙØ§ÙŠØª

client.on('message', async message => {
  var prefix = "q";     
  let messageArray = message.content.split(' ');
  let args = messageArray.slice(1);
  if(message.content.startsWith(prefix + "info-invite")) {
    if(!args) return message.reply('**Ø¢Ø±Ø³Ù„ ÙƒÙˆØ¯ Ø§Ù„Ø¯Ø¹ÙˆØ© Ù…Ø«Ø§Ù„ : ``VPRGM5``**');
    message.guild.fetchInvites().then(i => {
      let inv = i.get(args[0]);
      if(!inv) return message.reply(`**Ù„Ù… Ø§Ù‚Ø¯Ø± Ø¹Ù„Ù‰ Ø§ÙŠØ¬Ø§Ø¯ ${args}**`);
      const embed = new Discord.RichEmbed()
      .setAuthor(message.author.username,message.author.avatarURL)
      .setThumbnail(message.author.avatarURL)
      .addField('ØµØ§Ø­Ø¨ Ø§Ù„Ø¯Ø¹ÙˆØ©',inv.inviter,true)
      .addField('Ø±ÙˆÙ… Ø§Ù„Ø¯Ø¹ÙˆØ©',inv.channel,true)
      .addField('ØªØ§Ø±ÙŠØ® Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø¯Ø¹ÙˆØ©',moment(inv.expiresAt).format('YYYY/M/DD:h'),true)
      .addField('ØªÙ… Ø§Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ø¹ÙˆØ©',moment(inv.createdAt).format('YYYY/M/DD:h'),true)
      .addField('Ù…Ø¯Ø© Ø§Ù„Ø¯Ø¹ÙˆØ©',moment(inv.maxAge).format('DD **Ø³Ø§Ø¹Ø©** h **ÙŠÙˆÙ…**'),true)
      .addField('Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…Ø§Øª',inv.uses || inv.maxUses,true)
      .setFooter('Requested by '+message.author.username, message.author.avatarURL)
      message.channel.sendEmbed(embed);
    });
  }
});


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////Ø¹Ù…Ù„ Ø±ÙˆÙ… ÙÙˆÙŠØ³ Ø§Ùˆ ÙƒØªØ§Ø¨ÙŠ Ø¨ÙˆÙ‚Øª

 client.on('message', async message => {
    if(message.content.startsWith(prefix + "tv")) {
      if(!message.member.hasPermission('MANAGE_CHANNELS')) return;
      await message.channel.send("Ø§Ø±Ø³Ù„ Ø§Ø³Ù… Ø§Ù„Ø±ÙˆÙ…").then(e => {
      let filter = m => m.author.id === message.author.id
      let name = '';
      let time = '';
      let type = '';
      let limit = '';
  
     
      message.channel.awaitMessages(filter, { max: 1, time: 20000, errors: ['time'] })
      .then(collected => {
        name = collected.first().content
        collected.first().delete()
  
  
  
  e.edit("Ø§Ø±Ø³Ù„ Ù…Ø¯Ø© Ø§Ù„Ø±ÙˆÙ… Ø¨Ø§Ù„Ø¯Ù‚Ø§Ø¦Ù‚ Ù„Ø§Ø§Ù‚Ù„ Ù…Ù† 2 ÙˆÙ„Ø§ Ø§Ø¹Ù„Ù‰ Ù…Ù† 180")
  message.channel.awaitMessages(filter, { max: 1, time: 20000, errors: ['time'] })
  .then(co => {
  if(isNaN(co.first().content)) return message.reply("**Ø§Ù„ÙˆÙ‚Øª Ø¨Ø§Ù„Ø¯Ù‚Ø§Ø¦Ù‚ ! Ø§Ø±Ù‚Ø§Ù… ÙÙ‚Ø·Ù**");
  if(co.first().content > 180 || co.first().content < 2) return message.channel.send("**â° Ù„Ø§ Ø§Ù‚Ù„ Ù…Ù† Ø¯Ù‚ÙŠÙ‚ØªØ§Ù† ÙˆÙ„Ø§ Ø§ÙƒØ«Ø± Ù…Ù† 180 Ø¯Ù‚ÙŠÙ‚Ù‡**")
    time = co.first().content
  co.first().delete()
    e.edit("Ø§Ø±Ø³Ù„ Ù†ÙˆØ¹ Ø§Ù„Ø±ÙˆÙ… text, voice")
  message.channel.awaitMessages(filter, { max: 1, time: 20000, errors: ['time'] })
  .then(col => {
    type = col.first().content
  col.first().delete()
  e.edit("Ø§Ø±Ø³Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ø°ÙŠÙ† ÙŠØ³ØªØ·ÙŠØ¹ÙˆÙ† Ø§Ù„Ø¯Ø®ÙˆÙ„")
  message.channel.awaitMessages(filter, { max: 1, time: 20000, errors: ['time'] })
  .then(coll => {
    if(isNaN(coll.first().content)) return message.reply("**Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø¹Ø¶Ø§Ø¡ ÙŠÙƒÙˆÙ† Ø¨Ø§Ù„Ø§Ø±Ù‚Ø§Ù… ÙÙ‚Ø·**");
      limit = coll.first().content
  coll.first().delete()
  
    e.edit("Ø¬Ø§Ø±ÙŠ Ø§Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØºØ±ÙÙ‡ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø§Ù†ØªØ¶Ø§Ø±...")
    message.guild.createChannel(name, type).then(c => {
      c.edit({
        userLimit: limit
      })
      setTimeout(() => {
        c.delete()
        message.channel.send("**ØªÙ… Ø§Ù†Ù‚Ø¶Ø§Ø¡ Ø§Ù„ÙˆÙ‚Øª**")
      }, Math.floor(time*60000))
      
    })
    e.edit("**âœ… ØªÙ… Ø§Ù†Ø´Ø§Ø¡ Ø§Ù„ØºØ±ÙÙ‡ Ø§Ø³ØªÙ…ØªØ¹**")
  
  })
  })
  })
  })
  })
  
    }
  })



/////////////////////////////////////////////////////////////////////////////////////////////////






///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////// Un Ban All

client.on('message',async message => {
  if(message.content === 'qunbanall') {
    var user = message.mentions.users.first();
    if(!message.member.hasPermission('ADMINISTRATOR')) return message.channel.send('âŒ|**\`ADMINISTRATOR\`Ù„Ø§ ØªÙˆØ¬Ø¯ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© `**');
    if(!message.guild.member(client.user).hasPermission("BAN_MEMBERS")) return message.reply("**I Don't Have ` BAN_MEMBERS ` Permission**");
    const guild = message.guild;

  message.guild.fetchBans().then(ba => {
  ba.forEach(ns => {
  message.guild.unban(ns);
  const embed= new Discord.RichEmbed()
        .setColor("RANDOM")
        .setAuthor("Succes!", "https://cdn.discordapp.com/avatars/531967512464850944/036c049c69832d01d0e33915ff2f28ea.png?size=2048")
        .setDescription(`**:white_check_mark: Has Been Unban For All**`)
    .setFooter('Requested by '+message.author.username, message.author.avatarURL)
  message.channel.sendEmbed(embed);
  guild.owner.send(`Ø³ÙŠØ±ÙØ± : ${guild.name}
  **ØªÙ… ÙÙƒ Ø§Ù„Ø¨Ø§Ù†Ø¯ Ø¹Ù† Ø§Ù„Ø¬Ù…ÙŠØ¹ Ø¨ÙˆØ§Ø³Ø·Ø©** : <@${message.author.id}>`) 
  });
  });
  }
  });


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////user ÙƒØ§Ù…Ù„ Ø¨ÙƒØ§Ù… Ø¯Ø¹ÙˆÙ‡

client.on('message', message => {
    if(message.content.startsWith (prefix  + 'user')) {
     moment.locale('ar-ly');
var args = message.content.split(" ").slice(1); 
let user = message.mentions.users.first();
var men = message.mentions.users.first();
 var heg;
 if(men) {
     heg = men
 } else {
     heg = message.author
 }
var mentionned = message.mentions.members.first();
  var h;
 if(mentionned) {
     h = mentionned
 } else {
     h = message.member
 }
if (args == '') {
var z = message.author;
}else {
var z = message.mentions.users.first();
}
let oi = message.mentions.users.first() ? message.mentions.users.first().id : message.author.id ; 
  let img = message.mentions.users.first() ? message.mentions.users.first().username : message.author.username;
  let imagemm = message.mentions.users.first() ? message.mentions.users.first().avatarURL : message.author.avatarURL
  message.guild.fetchInvites().then(invs => {
    let member = client.guilds.get(message.guild.id).members.get(oi);
    let personalInvites = invs.filter(i => i.inviter.id === oi);
    let urll = invs.filter(i => i.inviter.id === oi);
    let link = urll.reduce((p , v) => v.url +` , Total de membros recrutados no convite: ${v.uses}.\n`+ p, `\nServidor: ${message.guild.name} \n `);
    let inviteCount = personalInvites.reduce((p, v) => v.uses + p, 0);
   let exec = personalInvites.reduce((p, v) => v.inviter);
 let possibleInvites = [['Total de membros recrutados:']];
possibleInvites.push([inviteCount, exec]);
        let user = message.mentions.users.first() || message.author;
        let mem = message.guild.member(user);
        let millisJoined = new Date().getTime() - mem.joinedAt.getTime();
        let daysJoined = millisJoined / 1000 / 60 / 60 / 24;
        let heroo = new Discord.RichEmbed()
        .setColor('RANDOM')
        .addField(':Ø¯Ø®ÙˆÙ„Ùƒ Ù„Ø¯ÙŠØ³ÙƒÙˆØ±Ø¯', `${moment(heg.createdTimestamp).format('YYYY/M/D HH:mm:ss')} **\n** \`${moment(heg.createdTimestamp).fromNow()}\`` ,true)
        .addField(':Ø§Ù†Ø¶Ù…Ø§Ù…Ùƒ Ù„Ø³ÙŠØ±ÙÙ†Ø§', `${moment(h.joinedAt).format('YYYY/M/D HH:mm:ss')} \n \`${moment(h.joinedAt).fromNow()}\``, true)
        .setTitle(`${z.username} **Info**`)
         .addField('Ø¹Ø¯Ø¯ Ø§Ù„Ø¯Ø¹ÙˆØ§Øª', `**${Number(inviteCount)}**`, true)
.setThumbnail(imagemm)
.setFooter(message.author.username, message.author.avatarURL);

     message.channel.send({embed:heroo});    
    });

};
});

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////Ban + unBan Voiceeee 
client.on('message', eyad => {
  if (eyad.content.startsWith('quvban')) {
if (!eyad.member.hasPermission("MOVE_MEMBERS")) return eyad.channel.send("**Ø§Ù†Øª Ù„Ø§ ØªÙ…ØªÙ„Ùƒ Ø§Ù„Ø®Ø§ØµÙŠÙ‡ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ù‡** | â ");
 let men = eyad.mentions.users.first()
 let mas = eyad.author
 if(!men) return eyad.channel.send('`â›”| ** ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ù…Ù†Ø´Ù† Ø§ÙˆÙ„Ø§Ù‹ **`');
 eyad.guild.channels.forEach(c => {
 c.overwritePermissions(men.id, {
         CONNECT: true
 })
    })
const embed = new Discord.RichEmbed()
.setColor("RANDOM")
.setDescription(`**
 <@${men.id}>
 Ø§Ù„Ø§Ù† ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„ÙŠ Ø§Ù„Ø±ÙˆÙ…Ø§Øª Ø§Ù„ØµÙˆØªÙŠÙ‡:)
Ø¨ÙˆØ§Ø³Ø·Ø© : <@${eyad.author.id}> **`)
.setThumbnail("http://shopforclipart.com/images/green-tick/22.jpg")
          
client.users.get(men.id).sendEmbed(embed)
const Embed11 = new Discord.RichEmbed()
.setColor("RANDOM")
.setAuthor(eyad.guild.name, eyad.guild.iconURL)
.setDescription(`          <@${men.id}>
Ø§Ù„Ø§Ù† ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„ÙŠ Ø§Ù„Ø±ÙˆÙ…Ø§Øª Ø§Ù„ØµÙˆØªÙŠÙ‡
Ø¨ÙˆØ§Ø³Ø·Ø© : <@${eyad.author.id}>
`)
.setThumbnail("http://shopforclipart.com/images/green-tick/22.jpg")
eyad.channel.sendEmbed(Embed11).then(eyad => {eyad.delete(15000)})
    }
}) // Ù†Ù‡Ø§ÙŠÙ‡ ÙƒÙˆØ¯ ÙÙƒ Ø§Ù„Ø¨Ø§Ù†Ø¯ Ø§Ù„ÙÙˆÙŠØ³
 
client.on('message', eyad => {
  if (eyad.content.startsWith('qvban')) {
if (!eyad.member.hasPermission("MOVE_MEMBERS")) return eyad.channel.send("â | **Ø§Ù†Øª Ù„Ø§ ØªÙ…ØªÙ„Ùƒ Ø§Ù„Ø®Ø§ØµÙŠÙ‡ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ù‡**");
let men = eyad.mentions.users.first()
let mas = eyad.author
if(!men) return eyad.channel.send('`â›”| ** ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ù…Ù†Ø´Ù† Ø§ÙˆÙ„Ø§Ù‹ **`');
eyad.guild.channels.forEach(c => {
c.overwritePermissions(men.id, {
          CONNECT: false
})
    })
const embed = new Discord.RichEmbed()
.setColor("RANDOM")
.setDescription(`**
 <@${men.id}>
Ù„Ù‚Ø¯ ØªÙ… Ù…Ù†Ø¹ Ù…Ù† Ø¯Ø®ÙˆÙ„ Ø§Ù„Ø±ÙˆÙ…Ø§Øª Ø§Ù„ØµÙˆØªÙŠÙ‡ 
Ø¨ÙˆØ§Ø³Ø·Ø© : <@${eyad.author.id}> **`)
.setThumbnail("http://www.clker.com/cliparts/o/Y/d/G/j/1/close-hi.png")
          
client.users.get(men.id).sendEmbed(embed)
const Embed11 = new Discord.RichEmbed()
.setColor("RANDOM")
.setAuthor(eyad.guild.name, eyad.guild.iconURL)
.setDescription(`          <@${men.id}>
Ù„Ù‚Ø¯ ØªÙ… Ù…Ù†Ø¹ Ù…Ù† Ø¯Ø®ÙˆÙ„ Ø§Ù„Ø±ÙˆÙ…Ø§Øª Ø§Ù„ØµÙˆØªÙŠÙ‡
Ø¨ÙˆØ§Ø³Ø·Ø© : <@${eyad.author.id}> `)
.setThumbnail("http://www.clker.com/cliparts/o/Y/d/G/j/1/close-hi.png")
eyad.channel.sendEmbed(Embed11).then(eyad => {eyad.delete(10000)})
    }
})// Ù†Ù‡Ø§ÙŠÙ‡ ÙƒÙˆØ¯ Ø§Ù„Ø¨Ø§Ù†Ø¯ Ø§Ù„ÙÙˆÙŠØ³
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////














///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////setReply ÙŠØ¹Ù†ÙŠ Ø§ÙƒØªØ¨ ÙƒÙ„Ù…Ø© ÙˆÙŠ Ø§ÙƒØªØ¨ Ø§Ù„Ø±Ø¯ Ø¨Ø³ Ø¨Ø¹Ø¯ Ø±ÙŠØ³ØªØ±Øª ØªØ¹ÙŠØ¯ Ù…ÙŠÙ† Ø§ÙˆÙ„ 


const reply = JSON.parse(fs.readFileSync('./replys.json' , 'utf8'));
client.on('message', async message => {
    let messageArray = message.content.split(" ");
   if(message.content.startsWith(prefix + "setReply")) {
    let filter = m => m.author.id === message.author.id;
    let thisMessage;
    let thisFalse;

    if(!message.member.hasPermission("MANAGE_GUILD")) return message.channel.send('You don\'t have permission').then(msg => {
       msg.delete(4500);
       message.delete(4500);
    });
    
    message.channel.send(':pencil: **| Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ø±Ø³Ø§Ù„Ù‡ Ø§Ù„Ø§Ù†... :pencil2: **').then(msg => {

        message.channel.awaitMessages(filter, {
          max: 1,
          time: 90000,
          errors: ['time']
        })
        .then(collected => {
            collected.first().delete();
            thisMessage = collected.first().content;
            let boi;
            msg.edit(':scroll: **| Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ø±Ø¯ Ø§Ù„Ø§Ù†... :pencil2: **').then(msg => {
      
                message.channel.awaitMessages(filter, {
                  max: 1,
                  time: 90000,
                  errors: ['time']
                })
                .then(collected => {
                    collected.first().delete();
                    boi = collected.first().content;
                    msg.edit('âœ… **| ØªÙ… Ø§Ù„Ø§Ø¹Ø¯Ø§Ø¯ Ø¨Ù†Ø¬Ø§Ø­...  **').then(msg => {
        
                      message.channel.awaitMessages(filter, {
                        max: 1,
                        time: 90000,
                        errors: ['time']
                      })
                      let embed = new Discord.RichEmbed()
                      .setTitle('**Done The Autoreply Code Has Been Setup**')
                      .addField('Message:', `${thisMessage}`)
                      .addField('Reply:', `${boi}`)
                      .setThumbnail(message.author.avatarURL)
                      .setFooter(`${client.user.username}`)
                     message.channel.sendEmbed(embed)
    reply[message.guild.id] = {
        msg: thisMessage,
        reply: boi,
    }
    fs.writeFile("./replys.json", JSON.stringify(reply), (err) => {
    if (err) console.error(err)
  })
   } 
            )
        })
    })
})
    })
}})             
client.on('message', async message => {
   if(message.content === reply[message.guild.id].msg) {
       message.channel.send(reply[message.guild.id].reply)
   }}
)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////Auto Role 


var prefix = "q";
let ar = JSON.parse(fs.readFileSync(`AutoRole.json`, `utf8`))
client.on('message', message => {
  var sender = message.author
 
if(!message.guild) return
  if(!ar[message.guild.id]) ar[message.guild.id] = {
  onoff: 'Off',
  role: 'Member'
  }
 
if(message.content.startsWith(`!autorole`)) {
         
  let perms = message.member.hasPermission(`MANAGE_ROLES`)
 
  if(!perms) return message.reply(`You don't have permissions, required permission : Manage Roles.`)
 let args = message.content.split(" ").slice(1)
 if(!args.join(" ")) return message.reply(`${prefix}autorole toggle / set [ROLE NAME]`)
 let state = args[0]
 if(!state.trim().toLowerCase() == 'toggle' || !state.trim().toLowerCase() == 'setrole') return message.reply(`Please type a right state, ${prefix}modlogs toggle/setrole [ROLE NAME]`)
   if(state.trim().toLowerCase() == 'toggle') {
    if(ar[message.guild.id].onoff === 'Off') return [message.channel.send(`**The Autorole Is __Ù‹â€ŒÚ¯Ú˜Ù‹â€ŒÚ¯Ú†__ !**`), ar[message.guild.id].onoff = 'On']
    if(ar[message.guild.id].onoff === 'On') return [message.channel.send(`**The Autorole Is __Ù‹â€ŒÚ¯Ú˜Ù‹â€ŒÚ¯â€¦Ù‹â€ŒÚ¯â€¦__ !**`), ar[message.guild.id].onoff = 'Off']
   }
  if(state.trim().toLowerCase() == 'set') {
  let newRole = message.content.split(" ").slice(2).join(" ")
  if(!newRole) return message.reply(`${prefix}autorole set [ROLE NAME]`)
    if(!message.guild.roles.find(`name`,newRole)) return message.reply(`I Cant Find This Role.`)
   ar[message.guild.id].role = newRole
    message.channel.send(`**The AutoRole Has Been Changed to ${newRole}.**`)
  }
        }
if(message.content === 'qinfo-autorole') {
   let perms = message.member.hasPermission(`MANAGE_GUILD`)
   if(!perms) return message.reply(`You don't have permissions.`)
    var embed = new Discord.RichEmbed()
 
.addField(`Autorole : :sparkles:  `, `
State : __${ar[message.guild.id].onoff}__
Role : __${ar[message.guild.id].role}__`)
 
 
    .setColor(`BLUE`)
    message.channel.send({embed})
  }
 
 
    fs.writeFile("./AutoRole.json", JSON.stringify(ar), (err) => {
    if (err) console.error(err)
  });
 
 
});//////////////Ø§Ø®ÙŠØ± Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø§ØªÙˆØ±ÙˆÙ„



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////  ØªØ­Øª Ø§Ù„Ø¨Ø±Ù…ÙŠÙˆÙ… ÙƒÙ„ Ø§Ù„ ÙÙŠ  Ù…Ø¬Ø§Ù†Ø§Ù ÙŠØ¨Ù‚Ø§ ØªØ­Øª Ø®Ø§Ù„Øµ ØªØ­Øª Ø§Ù„ÙƒÙ„Ø§Ù… Ø¯Ø§ ÙˆÙŠ Ø®Ù„Ø¨Ù„Ø§Ùƒ ØªÙƒØ±Ø± Ø­Ø§Ø¬Ø©  //////////////////////



///////////////Readyyy 



client.on('message', message => {
         if (message.content === "qcserver") {
		       if(!message.guild.member(client.user).hasPermission("MANAGE_CHANNELS")) return message.reply("**ÙŠØ­ØªØ§Ø¬ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù‰ Ø®Ø§ØµÙŠØ©` MANAGE_CHANNELS ` **").then(msg => msg.delete(6000))

                       if(!message.channel.guild) return message.reply('** This command only for servers **');
	                         if(!message.member.hasPermission('ADMINISTRATOR')) return      message.channel.send('**Ø£Ù†Øª Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø¨Ø±Ù…Ø´Ù†** `ADMINISTRATOR`' );
	const embed = new Discord.RichEmbed()
		.setDescription('** __ğŸ”¥  running...to make Channels | ÙŠØªÙ… Ø§Ù„Ø£Ù† Ø¹Ù…Ù„ Ø§Ù„Ø±ÙˆÙ…Ø§Øª Ø§Ù„ØµÙˆÙŠØªØ© ÙˆØ§Ù„ÙƒØªØ§Ø¨ÙŠØ©__ **')
		.setColor('RANDOM')
		.setFooter("**Quick Bot  **")
	message.channel.sendEmbed(embed);

message.guild.createChannel('Info', 'text');
message.guild.createChannel('Welcome', 'text');
message.guild.createChannel('ã€chatã€', 'text');
message.guild.createChannel('ã€botã€', 'text');
message.guild.createChannel('ã€bo7ã€', 'text');
message.guild.createChannel('ã€picã€', 'text');
message.guild.createChannel('ã€cutã€', 'text');
message.guild.createChannel('log', 'text');
message.guild.createChannel('â–“â–¬â–¬â–¬ADMNSâ–¬â–¬â–¬â–“', 'voice');
message.guild.createChannel('Owner ğŸ”¥- Ù…Ø§Ù„Ùƒ Ø§Ù„Ø³ÙŠØ±ÙØ±', 'voice');
message.guild.createChannel('Co OwnerğŸ”¥ - Ù†Ø§Ø¦Ø¨ Ø§Ù„Ø±Ø¦ÙŠØ³', 'voice');
message.guild.createChannel('Dev ğŸ”¥- Ù…Ø¨Ø±Ù…Ø¬ Ø§Ù„Ø³ÙŠØ±ÙØ±', 'voice');
message.guild.createChannel('Admin ğŸ”¥- Ù…Ø´Ø±Ù', 'voice');
message.guild.createChannel('Mod ğŸ”¥- Ù…ÙˆØ¯', 'voice');
message.guild.createChannel('â–“â–¬â–¬â–¬Otherâ–¬â–¬â–¬â–“', 'voice');
message.guild.createChannel('[ R E C ] ğŸ¥', 'voice');
message.guild.createChannel('YouTubers - ÙŠÙˆØªÙŠÙˆØ¨Ø±Ø²', 'voice');
message.guild.createChannel('VIP + - ÙƒØ¨Ø§Ø± Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø¨Ù„Ø³', 'voice');
message.guild.createChannel('VIP - ÙƒØ¨Ø§Ø± Ø§Ù„Ø´Ø®ØµÙŠØ§Øª', 'voice');
message.guild.createChannel('Friends - Ø§ØµØ¯Ù‚Ø§Ø¡', 'voice');
message.guild.createChannel('â–“â–¬â–¬â–¬WELâ–¬â–¬â–¬â–“', 'voice');
message.guild.createChannel('Help - Ù…Ø³Ø§Ø¹Ø¯Ø©', 'voice');
message.guild.createChannel('Îã€– Ø§Ù‚Ù€ØªÙ€Ø±Ø§Ø­Ù€Ø§ØªÙ€ÙƒÙ…Ù€ ğŸ’¡ ã€—', 'voice');
message.guild.createChannel('â–“â–¬â–¬â–¬â™šâ–¬â–¬â–¬â–“', 'voice');
message.guild.createChannel('â™§ Îã€– ğŸ¤  Ø³ÙˆØ§Ù„ÙŠÙ ğŸ“£  ã€—', 'voice');
message.guild.createChannel('â™¢ Îã€– ğŸ¤ Ù…ÙˆØ§Ù‡Ø¨ ğŸµ  ã€—', 'voice');
message.guild.createChannel('â‹ Îã€– ğŸˆÙØ¹Ø§Ù„ÙŠØ§Øª ğŸ… ã€—', 'voice');
message.guild.createChannel('â‹ Îã€–  ğŸ•‹ Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ…  ã€—', 'voice');
message.guild.createChannel('â–“â–¬â–¬â–¬â™›â–¬â–¬â–¬â–“', 'voice');
message.guild.createChannel('â˜†  Îã€– ğŸ”  Ø§Ù„Ø³Ø¬Ù† Ø§Ù„Ø¹Ø§Ù… ğŸ”ª ã€—', 'voice');
message.guild.createChannel('â–“â–¬â–¬â–¬Gamesâ–¬â–¬â–¬â–“', 'voice');
message.guild.createChannel('Clash of Clans | ÙƒÙ„Ø§Ø´ Ø£ÙˆÙ ÙƒÙ„Ø§Ù†Ø²', 'voice');
message.guild.createChannel('Clash Royal | ÙƒÙ„Ø§Ø´ Ø±ÙˆÙŠØ§Ù„', 'voice');
message.guild.createChannel('Hajwala  Online | Ù‡Ø¬ÙˆÙ„Ø© Ø£ÙˆÙ† Ù„Ø§ÙŠÙ†', 'voice');
message.guild.createChannel('Bullet force | Ø¨ÙˆÙ„Øª ÙÙˆØ±Ø³', 'voice');
message.guild.createChannel('MTA | Ø§Ù… ØªÙŠ Ø§ÙŠ', 'voice');
message.guild.createChannel('Ludo Star | Ù„ÙˆØ¯Ùˆ Ø³ØªØ§Ø±', 'voice');
message.guild.createChannel('â–“â–¬â–¬â–¬Privateâ–¬â–¬â–¬â–“', 'voice');
message.guild.createChannel('âœ¿Towâœ¿', 'voice');
message.guild.createChannel('âœ¿Threeâœ¿', 'voice');
message.guild.createChannel('âœ¿Fourâœ¿', 'voice');
message.guild.createChannel('âœ¿Fiveâœ¿', 'voice');
message.guild.createChannel('Quick Bot ğŸ”¥', 'voice');
message.guild.createChannel('â–“â–¬â–¬â–¬AFKâ–¬â–¬â–¬â–“', 'voice');
message.guild.createChannel('Away From keyboard AFK', 'voice');
message.guild.createChannel('â–“â–¬â–¬â–¬â™šâ–¬â–¬â–¬â–“', 'voice');

  console.log(`i make text channels in this server: ** ${message.guild.name} ** `)
  
}
});

////////////////////Create Roles 
client.on('message', message => {
	
	if (message.content === "qcserver") {
		      if(!message.guild.member(client.user).hasPermission("MANAGE_ROLES")) return message.reply("**ÙŠØ­ØªØ§Ø¬ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù‰ Ø®Ø§ØµÙŠØ©` MANAGE_ROLES ` **").then(msg => msg.delete(6000))

	              if(!message.channel.guild) return message.reply('** This command only for servers **');
	                         if(!message.member.hasPermission('ADMINISTRATOR')) return      message.channel.send('**Ø£Ù†Øª Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø¨Ø±Ù…Ø´Ù†** `ADMINISTRATOR`' );
		          const embed = new Discord.RichEmbed()
		.setDescription(' __ğŸ”¥ running...to make roles | ÙŠØªÙ… Ø§Ù„Ø£Ù† Ø¹Ù…Ù„ Ø§Ù„Ø±ØªØ¨__ ')
		.setColor('RANDOM')
		.setFooter("**Quick Bot ğŸ”¥**")
	message.channel.sendEmbed(embed);
		   

  message.guild.createRole({
        name : "Owner",
        permissions :   [1],
        color : " #000000"
    })
    message.guild.createRole({
        name : "Co-Owner",
        permissions :   [1],
        color : " #000000"
    })
      message.guild.createRole({
        name : "Leader",
        permissions :   [1],
        color : " #EE82EE"
    })
    message.guild.createRole({
        name : "Co-Leader",
        permissions :   [1],
        color : " #EE82EE"
    })
  
     message.guild.createRole({
        name : "Admin",
        permissions :   [1],
        color : " #8A2BE2"
    })
    
     message.guild.createRole({
        name : "GAMING",
        permissions :   [1],
        color : " #RANDOM"
    })
    

  
    message.guild.createRole({
        name : "Mod",
        permissions :   [1],
        color : " #8A2BE2"
    })
    message.guild.createRole({
        name : "ï¼¶ï¼©ï¼° + ",
        permissions :   [1],
        color : "  #7CFC00"
    })
    message.guild.createRole({
        name : "ï¼¶ï¼©ï¼°",
        permissions :   [1],
        color : " #7CFC00"
    })
    message.guild.createRole({
        name : "Support ",
        permissions :   [1],
        color : " #FFD700"
    })

  message.guild.createRole({
        name : "YouTuber+200",
        permissions :   [1],
        color : " #8B0000"
    })
   
    message.guild.createRole({
        name : "YouTuber",
        permissions :   [1],
        color : " #FF0000"
    })
    
      message.guild.createRole({
        name : "Pro Memberâ˜¤",
        permissions :   [1],
        color : " #ffffff"
    })
    
          message.guild.createRole({
        name : "ğŸŒ¹ã€ŒFriendlyã€",
        permissions :   [1],
        color : " #9932CC"
    })
  
 
    message.guild.createRole({
        name : "â˜¤Memberâ˜¤",
        permissions :   [1],
        color : " #ffffff"
    })
    
        message.guild.createRole({
        name : "Bot",
        permissions :   [1],
        color : " #ffffff"
    })
    
    message.guild.createRole({
        name : "CrossFire",
        permissions :   [1],
        color : " #ffffff"
    })     
  
    message.guild.createRole({
        name : "PUBG",
        permissions :   [1],
        color : " #ffffff"
    })    
   
     message.guild.createRole({
        name : "BlackSquad",
        permissions :   [1],
        color : " #ffffff"
    })      
  console.log(`i make rools in this server: ** ${message.guild.name} ** `);
}
});


client.on('message', message => {
	///////////
	var command = message.content.toLowerCase().split(" ")[0];
	var args = message.content.toLowerCase().split(" ");
if(null == message.guild || !message.guild) return;
	var userM = message.guild.member(message.mentions.users.first() || message.guild.members.find(m => m.id === args[1]));
	var logChannel = message.guild.channels.find(c => c.name === 'log');
	var prefix = 'q';
	
	if(command == prefix + 'ban') {
	if(!message.channel.guild) return message.reply(':no_entry: | This Command For Servers Only!'); 
        if(!message.member.hasPermission('BAN_MEMBERS')) return message.channel.send(':no_entry: | You dont have **BAN_MEMBERS** Permission!');
        if(!message.guild.member(client.user).hasPermission('BAN_MEMBERS')) return message.channel.send(':no_entry: | I dont have **BAN_MEMBERS** Permission!');
		if(!message.guild.member(client.user).hasPermission('EMBED_LINKS')) return message.channel.send(':no_entry: | I dont have **EMBED_LINKS** Permission!');
///////////
		if(!userM) return message.channel.send(`**â¥ Useage:** ${prefix}ban \`\`@Name\`\` time reason`);
		if(userM.user.id === message.author.id) return message.channel.send(':no_entry: | Why you want ban **Your Self** ?');
		if(userM.user.id === message.guild.owner.id) return message.channel.send(':no_entry: | Nice try dude \:D');
		if(message.guild.member(userM.user).highestRole.position >= message.guild.member(message.member).highestRole.position) return message.channel.send(`:no_entry: | You cant give **${userM.user.username}** Ban beacuse him role highest then your role!`);
		if(message.guild.member(userM.user).highestRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I cant give **${userM.user.username}** Ban beacuse him role highest then my role!`);
		if(!message.guild.member(userM.user).bannable) return message.channel.send(`:no_entry: | I cant give **${userM.user.username}** Ban.`);
///////////
		var time = message.content.split(" ")[2];
		if(!time) time = '1d';

		if(!ms(time)) {
			var reason = message.content.split(' ')[2];
		}else {
			var reason = message.content.split(' ')[3];
		}
		
		if(!reason) reason = 'No reason provided.';
		
		userM.user.send(`:no_entry: | You have \`\`BANNED\`\` From the server **${message.guild.name}**, By: **${message.author.tag}**, Reason: \`\`${reason}\`\`, Time: **${time}**`).catch();
        message.guild.member(userM.user).ban({ reason: reason });
        message.channel.send(`:white_check_mark: | Successfully \`\`BANNED\`\` ${userM.user.username} from the server! :airplane: \`\`${reason}\`\``);
		///////////
		let banInfo = new Discord.RichEmbed()
		.setTitle('**[BANNED]**')
		.setThumbnail(message.author.avatarURL)
		.setColor('GREEN')
		.setDescription(`**\n:airplane: Successfully \`\`BANNED\`\` **${userM.user.username}** From the server!\n\n**User:** <@${userM.user.id}> (ID: ${userM.user.id})\n**By:** <@${message.author.id}> (ID: ${message.author.id})\n**Reason:** \`\`${reason}\`\`\n**Time:** ${time}`)
		.setTimestamp()
		.setFooter(userM.user.tag, userM.user.avatarURL)
		
		if(logChannel) {
			logChannel.send(banInfo);
		}
		///////////
		setTimeout(function() {
			message.guild.fetchBans().then(bans => {
				var Found = bans.find(m => m.id === userM.user.id);
				if(!Found) return;
				
				message.guild.unban(userM.user);
			
				let unbanInfo = new Discord.RichEmbed()
				.setTitle('**[UNBANNED]**')
				.setThumbnail(message.guild.iconURL)
				.setColor('GREEN')
				.setDescription(`**\n:airplane: Successfully \`\`UNBANNED\`\` **${userM.user.username}** From the server!\n\n**User:** <@${userM.user.id}> (ID: ${userM.user.id})\n**Reason:** \`\`Time Ended.\`\``)
				.setTimestamp()
				.setFooter(userM.user.tag, userM.user.avatarURL)
				
				if(logChannel) {
					logChannel.send(banInfo);
				}
			})
		}, ms(time))
	}
	if(command == prefix + 'unban') {
		/////////
		 if(!message.channel.guild) return message.reply(':no_entry: | This Command For Servers Only!'); 
		if(!message.member.hasPermission('BAN_MEMBERS')) return message.channel.send(':no_entry: | You dont have **BAN_MEMBERS** Permission!');
		if(!message.guild.member(client.user).hasPermission("BAN_MEMBERS")) return message.channel.send(':no_entry: | I dont have **BAN_MEMBERS** Permission!');
		if(!args[1]) return  message.channel.send(':no_entry: | Please type the ID of user');
		if(args[1].length < 16) return message.reply(':no_entry: | This ID is not id user!');
		message.guild.fetchBans().then(bans => {
			var Found = bans.find(m => m.id === args[1]);
			if(!Found) return message.channel.send(`:no_entry: | <@${message.author.id}> This preson not have any ban from this server! :unlock:`);
			message.guild.unban(args[1]);
			message.channel.send(`:white_check_mark: Successfully \`\`UNBANNED\`\` <@${args[1]}> From the server!`);
			//xRGRx .. By Julian
			let banInfo = new Discord.RichEmbed()
			.setTitle('**[UNBANNED]**')
			.setThumbnail(message.author.avatarURL)
			.setColor('GREEN')
			.setDescription(`**\n:airplane: Successfully \`\`UNBANNED\`\` <@${args[1]}> From the server!\n\n**User:** <@${args[1]}> (ID: ${args[1]})\n**By:** <@${message.author.id}> (ID: ${message.author.id})`)
			.setTimestamp()
			.setFooter(userM.user.tag, userM.user.avatarURL)
			
			if(logChannel) {
				logChannel.send(banInfo);
			}
		})
	}
});




               client.on('message', message => {
                   var prefix = "q"
                 if (message.author.x5bz) return;
                 if (!message.content.startsWith(prefix + "kick" )) return;

                 let command = message.content.split(" ")[0];
                 command = command.slice(prefix.length);

                 let args = message.content.split(" ").slice(1);

                 if (command == "kick") {
                              if(!message.channel.guild) return message.reply('** This command only for servers**');

                 if(!message.guild.member(message.author).hasPermission("KICK_MEMBERS")) return message.reply("**You Don't Have ` KICK_MEMBERS ` Permission**");
                 if(!message.guild.member(client.user).hasPermission("KICK_MEMBERS")) return message.reply("**I Don't Have ` KICK_MEMBERS ` Permission**");
                 let user = message.mentions.users.first();
                 let reason = message.content.split(" ").slice(2).join(" ");
                 if (message.mentions.users.size < 1) return message.reply("**Ù…Ù†Ø´Ù† Ø´Ø®Øµ**");
                 if(!reason) return message.reply ("**Ø§ÙƒØªØ¨ Ø³Ø¨Ø¨ Ø§Ù„Ø·Ø±Ø¯**");
                 if (!message.guild.member(user)
                 .kickable) return message.reply("**Ù„Ø§ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ø·Ø±Ø¯ Ø´Ø®Øµ Ø§Ø¹Ù„Ù‰ Ù…Ù† Ø±ØªØ¨ØªÙŠ ÙŠØ±Ø¬Ù‡ Ø§Ø¹Ø·Ø§Ø¡ Ø§Ù„Ø¨ÙˆØª Ø±ØªØ¨Ù‡ Ø¹Ø§Ù„ÙŠ**");

                 message.guild.member(user).kick();

                 const kickembed = new Discord.RichEmbed()
                 .setAuthor(`KICKED!`, user.displayAvatarURL)
                 .setColor("RANDOM")
                 .setTimestamp()
                 .addField("**User:**",  '**[ ' + `${user.tag}` + ' ]**')
                 .addField("**By:**", '**[ ' + `${message.author.tag}` + ' ]**')
                 .addField("**Reason:**", '**[ ' + `${reason}` + ' ]**')
                 message.channel.send({
                   embed : kickembed
                 })
               }
               });

client.on('message', message => {
  if(!message.channel.guild) return;
  if(message.content.startsWith(prefix + 'move')) {
   if (message.member.hasPermission("MOVE_MEMBERS")) {
   if (message.mentions.users.size === 0) {
   return message.channel.send("``Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ù…Ø± Ø§ÙƒØªØ¨ Ù‡Ø°Ù‡ Ø§Ù„Ø£Ù…Ø± : " +prefix+ "move [USER]``")
  }
  if (message.member.voiceChannel != null) {
   if (message.mentions.members.first().voiceChannel != null) {
   var authorchannel = message.member.voiceChannelID;
   var usermentioned = message.mentions.members.first().id;
  var embed = new Discord.RichEmbed()
   .setTitle("Succes!")
   .setColor("#000000")
   .setDescription(`Ù„Ù‚Ø¯ Ù‚Ù…Øª Ø¨Ø³Ø­Ø¨ <@${usermentioned}> Ø§Ù„Ù‰ Ø§Ù„Ø±ÙˆÙ… Ø§Ù„ØµÙˆØªÙŠ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒâœ… `)
  var embed = new Discord.RichEmbed()
  .setTitle(`You are Moved in ${message.guild.name}`)
   .setColor("RANDOM")
  .setDescription(`**<@${message.author.id}> Moved You To His Channel!\nServer --> ${message.guild.name}**`)
   message.guild.members.get(usermentioned).setVoiceChannel(authorchannel).then(m => message.channel.send(embed))
  message.guild.members.get(usermentioned).send(embed)
  } else {
  message.channel.send("``Ù„Ø§ ØªØ³ØªØ·ÙŠØ¹ Ø³Ø­Ø¨ "+ message.mentions.members.first() +" `ÙŠØ¬Ø¨ Ø§Ù† ÙŠÙƒÙˆÙ† Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ø¶Ùˆ ÙÙŠ Ø±ÙˆÙ… ØµÙˆØªÙŠ`")
  }
  } else {
   message.channel.send("**``ÙŠØ¬Ø¨ Ø§Ù† ØªÙƒÙˆÙ† ÙÙŠ Ø±ÙˆÙ… ØµÙˆØªÙŠ Ù„ÙƒÙŠ ØªÙ‚ÙˆÙ… Ø¨Ø³Ø­Ø¨ Ø§Ù„Ø¹Ø¶Ùˆ Ø£Ù„ÙŠÙƒ``**")
  }
  } else {
  message.react("âŒ")
   }}});
 




//////////////////////////////////////  ÙƒÙˆØ¯ Ø§Ù„Ø§ÙØªØ§Ø± 
client.on('message', message => {
  if (!message.content.startsWith(prefix)) return;
  var args = message.content.split(' ').slice(1);
  var argresult = args.join(' ');
       if (message.content.startsWith(prefix + "avatar")) {
           var mentionned = message.mentions.users.first();
    var MsH;
      if(mentionned){
          var MsH = mentionned;
      } else {
          var MsH = message.author;
         
      }
          message.channel.send(MsH.avatarURL)
          message.delete(3000);
      }
         
});


 
          client.on('message', message => {
                 if(message.content === "qmc") {
                                     if(!message.channel.guild) return message.reply("**This command only for servers**");

             if(!message.member.hasPermission('MANAGE_MESSAGES')) return message.reply("**__Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ§Øª__**");
                        message.channel.overwritePermissions(message.guild.id, {
                      SEND_MESSAGES: false

                        }).then(() => {
                            message.reply("**__ØªÙ… ØªÙ‚ÙÙŠÙ„ Ø§Ù„Ø´Ø§Øª__:red_circle:  https://cdn.discordapp.com/attachments/519248442804011032/519256944045719582/giphy_1.gif **")
                        });
                          }

              if(message.content === "qunmc") {
                                  if(!message.channel.guild) return message.reply("**This command only for servers**");

             if(!message.member.hasPermission('MANAGE_MESSAGES')) return message.reply("**__Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ§Øª__**");
                        message.channel.overwritePermissions(message.guild.id, {
                      SEND_MESSAGES: true

                        }).then(() => {
                            message.reply("**__ØªÙ… ÙØªØ­ Ø§Ù„Ø´Ø§Øª__**:large_blue_circle: https://cdn.discordapp.com/attachments/519248442804011032/519256944045719582/giphy_1.gif")
                        });
              }

          });

 

                  client.on('message', message => {
                           if (message.content.startsWith("qbotinfo")) {
                    let embed = new Discord.RichEmbed()
               .setThumbnail(message.author.avatarURL)
               .addField(' Ø§Ù„Ø³ÙŠØ±ÙØ±Ø§ØªğŸŒ',`[${client.guilds.size}]  `)
               .addField('**Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ğŸ‘¥ **' , `${client.users.size}`, true)
               .addField('Ø§Ù„Ø±ÙˆÙ…Ø§ØªğŸ“š ',`[${client.channels.size}]`)
               .addField(' Ø§Ù„Ø¨Ù†Ù‚ğŸš€ ',`[${Date.now() - message.createdTimestamp}]`)
	       .addField('**Ø³Ø±Ø¹Ø© Ø§Ù„Ø§ØªØµØ§Ù„ğŸ“¡**' , `${Date.now() - message.createdTimestamp}` + ' ms')
               .addField('**Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬ğŸ’¿**', `${(process.cpuUsage().rss / 10000).toFixed()}%`, true) 
               .addField(`Quick Bot â™¥`)
               .setColor('#7d2dbe')
                 message.channel.sendEmbed(embed);
                   }
               });



               client.on('message', message => {
                           if(!message.channel.guild) return;
               let args = message.content.split(' ').slice(1).join(' ');
               if (message.content.startsWith('qabc')){
                if (message.author.id !== '513642775259119636') return message.reply('** Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù‚ÙØ· Ù„ØµØ§Ø­Ø¨ Ø§Ù„Ø¨ÙˆØª Ùˆ Ø´ÙƒØ±Ø§Ù‹Ù‹ **')
               message.channel.sendMessage('Ø¬Ø§Ø± Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© |âœ…')
               client.users.forEach(m =>{
               m.sendMessage(args)
               })
               }
               });

////////////////////////////////////////////////////3dad Members le admin bss






//////////// clear chat 



client.on('message', message => {
	var prefix = "q";
   if(!message.channel.guild) return;
if(message.content.startsWith(prefix + 'clear')) {
if(!message.channel.guild) return message.channel.send('**This Command is Just For Servers**').then(m => m.delete(5000));
if(!message.member.hasPermission('MANAGE_MESSAGES')) return      message.channel.send('**You Do not have permission** `MANAGE_MESSAGES`' );
let args = message.content.split(" ").join(" ").slice(2 + prefix.length);
let request = `Requested By ${message.author.username}`;
message.channel.send(`**Are You sure you want to clear the chat?**`).then(msg => {
msg.react('âœ…')
.then(() => msg.react('âŒ'))
.then(() =>msg.react('âœ…'))

let reaction1Filter = (reaction, user) => reaction.emoji.name === 'âœ…' && user.id === message.author.id;
let reaction2Filter = (reaction, user) => reaction.emoji.name === 'âŒ' && user.id === message.author.id;

let reaction1 = msg.createReactionCollector(reaction1Filter, { time: 12000 });
let reaction2 = msg.createReactionCollector(reaction2Filter, { time: 12000 });
reaction1.on("collect", r => {
message.channel.send(`Chat will delete`).then(m => m.delete(5000));
var msg;
        msg = parseInt();

      message.channel.fetchMessages({limit: msg}).then(messages => message.channel.bulkDelete(messages)).catch(console.error);
      message.channel.sendMessage("", {embed: {
        title: "`` Chat Deleted ``",
        color: 0x06DF00,
        footer: {

        }
      }}).then(msg => {msg.delete(3000)});

})
reaction2.on("collect", r => {
message.channel.send(`**Chat deletion cancelled**`).then(m => m.delete(5000));
msg.delete();
})
})
}
});

 






/// ÙŠØ¯ÙŠÙƒ Ø§Ù„Ø³ÙŠØ±ÙØ±Ø§Øª Ø§Ù„Ù‰ ÙÙŠÙ‡Ø§ Ø§Ù„Ø¨ÙˆØª 



  client.on('message', msg => {
    if(msg.author.bot) return;
    
    if(msg.content === 'qsr') {
      client.guilds.forEach(g => {
        
        let l = g.id
        g.channels.get(g.channels.first().id).createInvite({
          maxUses: 5,
          maxAge: 86400
        }).then(i => msg.channel.send(`
        **
        Invite Link : <https://discord.gg/${i.code}>
        Server : ${g.name} | Id : ${g.id} 
        Owner ID : ${g.owner.id}
        **
        `))
  
  
      })
    }
    
  })


//Emoji


client.on('message' , async (message) => {
       if(message.content.startsWith(prefix + "emoji")) {
          let args = message.content.split(" ").slice(1);
  if (args.length < 1) {
    message.channel.send('You must provide some text to emojify!');
}

message.channel.send(
    args.join(' ')
        .split('')
        .map(c => mapping[c] || c)
        .join('')
);
};
});




//////uptime

client.on('message', message => {
     if (message.author.bot) return;
if (message.content.startsWith(prefix + "uptime")) {
    let uptime = client.uptime;

    let days = 0;
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    let notCompleted = true;

    while (notCompleted) {

        if (uptime >= 8.64e+7) {

            days++;
            uptime -= 8.64e+7;

        } else if (uptime >= 3.6e+6) {

            hours++;
            uptime -= 3.6e+6;

        } else if (uptime >= 60000) {

            minutes++;
            uptime -= 60000;

        } else if (uptime >= 1000) {
            seconds++;
            uptime -= 1000;

        }

        if (uptime < 1000)  notCompleted = false;

    }

    message.channel.send("**" + `:control_knobs:${days} days, ${hours} hrs, ${minutes} , ${seconds} sec` + "**");

}
});


//////////no Invite Discord


client.on('message', message => {
    if(message.content.includes('discord.gg')){
if(!message.channel.guild) return 
if (message.author.bot) return;
        if (!message.member.hasPermissions(['ADMINISTRATOR'])){
        message.delete()
    return message.reply(`** Not allowed to advertising Here :broken_heart: **`)
    }
}
});


/////////////Voice Online


client.on('message',async message => {
  if(message.content.startsWith(prefix + "voiceonline")) {
  if(!message.guild.member(message.author).hasPermissions('MANAGE_CHANNELS')) return message.reply(':x: **Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„ÙƒØ§ÙÙŠØ©**');
  if(!message.guild.member(client.user).hasPermissions(['MANAGE_CHANNELS','MANAGE_ROLES_OR_PERMISSIONS'])) return message.reply(':x: **Ù„ÙŠØ³ Ù…Ø¹ÙŠ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„ÙƒØ§ÙÙŠØ©**');
  message.channel.send(':white_check_mark:| **ØªÙ… Ø¹Ù…Ù„ Ø§Ù„Ø±ÙˆÙ… Ø¨Ù†Ø¬Ø§Ø­**');
  message.guild.createChannel(`Voice Online : [ ${message.guild.members.filter(m => m.voiceChannel).size} ]` , 'voice').then(c => {
    console.log(`Voice online channel setup for guild: \n ${message.guild.name}`);
    c.overwritePermissions(message.guild.id, {
      CONNECT: false,
      SPEAK: false
    });
    setInterval(() => {
      c.setName(`Voice Online : [ ${message.guild.members.filter(m => m.voiceChannel).size} ]`)
    },1000);
  });
  }
});


client.on('message', message => {

  var ms = require('ms')
 
  var moment = require('moment');
 
  var prefix = "q"
   
  if (message.author.x5bz) return;
 
  if (!message.content.startsWith(prefix)) return;
 
  let command = message.content.split(" ")[0];
 
  command = command.slice(prefix.length);
 
  let args = message.content.split(" ").slice(1);
 
  let messageArray = message.content.split(" ");
 
  let muteRole = message.guild.roles.find("name", "Muted");

  let embed = new Discord.RichEmbed()
 
 .setImage("https://cdn.discordapp.com/attachments/532720919316135951/532765136721805322/unknown.png")
 
  if (command == "mute") {
    
  if(!muteRole) return message.guild.createRole({ name: "Muted", permissions: [] });

  if(!message.channel.guild) return message.reply('** This Command only for Servers**');
          
  if(!message.guild.member(message.author).hasPermission("MUTE_MEMBERS")) return message.reply("**:x: You Don't Have ` MUTE_MEMBERS ` Permission**");
 
  if(!message.guild.member(client.user).hasPermission("MUTE_MEMBERS")) return message.reply("**:x: I Don't Have ` MUTE_MEMBERS ` Permission**");
 
  let user = message.mentions.users.first();
 
  let Reason = message.content.split(" ").slice(4).join(" ");
 
  let time = messageArray[2];
 
  if (message.mentions.users.size < 1) return message.channel.sendEmbed(embed)
   
  if (!message.guild.member(user).bannable) return message.reply("**:x:I Don't Have Permission For Mute This User**");
 
  if(!Reason)  {
 
    message.guild.member(user).addRole(muteRole);
 
  }
 
   if(!Reason && time) {
 
    message.guild.member(user).addRole(muteRole);
 
   }  
 
   if(!time) {
 
    message.guild.member(user).addRole(muteRole);
 
   }
   if(time) {
    if(!time.match(/[1-60][s,m,h,d,w]/g))  return message.channel.send(':x: This Time Is Incorrect')

   setTimeout(() => {
 
    message.guild.member(user).removeRole(muteRole);
 
   }, ms(time));
 
   }
 
   if(time && Reason && user) {
 
    message.guild.member(user).addRole(muteRole);
 
   setTimeout(() => {
 
    message.guild.member(user).removeRole(muteRole);
   
   }, ms(time));
 
   }
 
   message.channel.send(`:white_check_mark: ${user} has been muted ! :zipper_mouth:`)
 
   }
 
   });


////////////////////

//////////////ykrar el Klam fe Embed 


client.on('message', message => {
  if (message.author.bot) return;
  if (!message.content.startsWith(prefix)) return;

  let command = message.content.split(" ")[0];
  command = command.slice(prefix.length);

  let args = message.content.split(" ").slice(1);
  
 

if (command == "embed") {
    let say = new Discord.RichEmbed()
    .setDescription(args.join("  "))
    .setColor("RANDOM")
    message.channel.sendEmbed(say);
    message.delete();
  }



});///a5er code




///////////////////////////////kAM Members fe server Mtwar fa45 men tsmemy

client.on('message', message => {
              if (!message.channel.guild) return;
      if(message.content =='qcount')
      var Mahmoud = new Discord.RichEmbed()
      .addField(' All Members In ServerğŸ‘¥. .',`${message.guild.memberCount}`)
      message.channel.send(Mahmoud);
    });


///a5ero 





/////////////////////////tag


client.on('message', message => {
if(message.content.startsWith('qdiscrim') ) {
     if(!message.channel.guild) return message.reply('** This command only for servers **')
     
          var args = message.content.split(" ").slice(1);
    let sent = 0
	let count = 1;
	
      if(args){
client.users.filter(u => u.discriminator == args[0]).forEach(u => {
    if(sent > 4){
     return
    }
    sent = sent + 1
      message.channel.send(`
      ** ${count}â¥ ${u.tag}**
         
      `)
      count++;
   
      })
      } 
      
}

if(message.content ===('qdiscrim') ) {
     if(!message.channel.guild) return message.reply('** This command only for servers **')
  let sent = 0
	let count = 1;
          

client.users.filter(u => u.discriminator == message.author.discriminator).forEach(u => {
    if(sent > 4){
        return
    }
    sent = sent + 1
      message.channel.send(`
      ** ${count}â¥ ${u.tag}**
         
      `)
      count++;
   
      })
          
      }

 
});



///////////////////////////////////////ct an4a2 room text

 client.on("message", (message) => {
if (message.content.startsWith("qct")) {
            if (!message.member.hasPermission('MANAGE_CHANNELS')) return message.reply("You Don't Have `MANAGE_CHANNELS` Premissions ");
        let args = message.content.split(" ").slice(1);
    message.guild.createChannel(args.join(' '), 'text');
message.channel.sendMessage('**:ballot_box_with_check: ØªÙ€Ù… Ø¥Ù†Ù€Ø´Ø§Ø¡ Ø±ÙˆÙ… ÙƒÙ€ØªØ§Ø¨Ù€ÙŠ**')

}
});

/////////////////////////Room Swtny an4a2

client.on("message", (message) => {
if (message.content.startsWith("qcv")) {
            if (!message.member.hasPermission('MANAGE_CHANNELS')) return message.reply("You Don't Have `MANAGE_CHANNELS` Premissions ");
        let args = message.content.split(" ").slice(1);
    message.guild.createChannel(args.join(' '), 'voice');
    message.channel.sendMessage(':white_check_mark: ØªÙ€Ù… Ø¥Ù†Ù€Ø´Ø§Ø¡ Ø±ÙˆÙ… ØµÙ€ÙˆØªÙŠ')
    
}
});





////////////ping Tsmemy :'D 




//////////// Swret el server 

client.on("message", message => {
    const prefix = "q"
              
          if(!message.channel.guild) return;
   if(message.author.bot) return;
      if(message.content === prefix + "image"){ 
          const embed = new Discord.RichEmbed()
  
      .setTitle(`This is  ** ${message.guild.name} **  Photo !`)
  .setAuthor(message.author.username, message.guild.iconrURL)
    .setColor(0x164fe3)
    .setImage(message.guild.iconURL)
    .setURL(message.guild.iconrURL)
                    .setTimestamp()

   message.channel.send({embed});
      }
  });















client.login(process.env.BOT_TOKEN); 

 



